<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Продвинутый редактор 3D-поверхностей v3</title>
    <!-- 1. Библиотека Plotly -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- 2. Библиотеки для экспорта в PDF (ВАЖНО!) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0; padding: 1.5em; background-color: #f0f2f5; color: #333;
        }
        .container { max-width: 1600px; margin: auto; }
        h1 { text-align: center; color: #0056b3; }
        details {
            border: 1px solid #ccc; border-radius: 8px; margin-bottom: 1em;
            padding: 0.5em 1em; background-color: #fff;
        }
        summary { font-weight: bold; cursor: pointer; padding: 0.5em; color: #0056b3; }
        .controls-panel {
            display: flex; flex-wrap: wrap; gap: 20px; align-items: flex-end;
            justify-content: center; padding: 1em; background-color: #fff;
            border-radius: 8px; margin-bottom: 1em; border: 1px solid #ddd;
        }
        .control-group { display: flex; flex-direction: column; }
        .control-group label { margin-bottom: 5px; font-size: 0.9em; color: #555; }
        .control-group input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 120px; }
        .control-group input[type="text"] { width: 150px; }
        button {
            padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer;
            background-color: #007bff; color: white; transition: background-color 0.2s;
        }
        button:hover { background-color: #0056b3; }
        button#mode-toggle-btn.edit-mode { background-color: #28a745; }
        button#mode-toggle-btn.edit-mode:hover { background-color: #218838; }
        button.reset-btn { background-color: #dc3545; }
        button.reset-btn:hover { background-color: #c82333; }
        
        /* Стили для виджетов с графиками */
        .plots-area {
            display: flex; flex-wrap: wrap; justify-content: center;
            align-items: flex-start; gap: 20px; margin-top: 20px;
        }
        .plot-widget {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .plot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .plot-title {
            font-weight: bold;
            color: #333;
        }
        .export-buttons button {
            padding: 4px 8px;
            font-size: 12px;
            margin-left: 5px;
            background-color: #6c757d;
        }
        .export-buttons button:hover {
             background-color: #5a6268;
        }
        .plot-2d-wrapper { display: flex; flex-direction: column; gap: 20px; }
        .plot-2d { width: 500px; height: 350px; }
        .plot-3d { width: 700px; height: 720px; }

        .table-section { display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; padding: 1em; }
        .table-container { max-height: 400px; overflow-y: auto; border: 1px solid #ddd; }
        table { border-collapse: collapse; width: 300px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #f2f2f2; }
        td input { width: 80%; border: 1px solid #ccc; text-align: center; padding: 4px;}
    </style>
</head>
<body>
    <div class="container">
        <h1>Продвинутый редактор 3D-поверхностей</h1>
        <!-- Инструкции и панель управления без изменений -->
        <details open><summary>Инструкция по использованию</summary><!-- ... --></details>
        <details open><summary>Панель управления</summary><!-- ... --></details>

        <div class="plots-area">
            <div class="plot-2d-wrapper">
                <!-- Виджет для графика X -->
                <div class="plot-widget" id="widget-plotX">
                    <div class="plot-header">
                        <span class="plot-title">Профиль Y от X</span>
                        <div class="export-buttons">
                            <button data-format="png">PNG</button>
                            <button data-format="svg">SVG</button>
                            <button data-format="pdf">PDF</button>
                        </div>
                    </div>
                    <div id="plotX" class="plot-2d"></div>
                </div>

                <!-- Виджет для графика Z -->
                <div class="plot-widget" id="widget-plotZ">
                    <div class="plot-header">
                        <span class="plot-title">Профиль Y от Z</span>
                        <div class="export-buttons">
                            <button data-format="png">PNG</button>
                            <button data-format="svg">SVG</button>
                            <button data-format="pdf">PDF</button>
                        </div>
                    </div>
                    <div id="plotZ" class="plot-2d"></div>
                </div>
            </div>

            <!-- Виджет для 3D-графика -->
            <div class="plot-widget" id="widget-plot3D">
                <div class="plot-header">
                    <span class="plot-title">Итоговая 3D-поверхность</span>
                    <div class="export-buttons">
                        <button data-format="png">PNG</button>
                        <button data-format="svg">SVG</button>
                        <button data-format="pdf">PDF</button>
                    </div>
                </div>
                <div id="plot3D" class="plot-3d"></div>
            </div>
        </div>
        
        <!-- Таблицы теперь всегда открыты -->
        <details open>
            <summary>Табличные данные профилей</summary>
            <div class="table-section">
                <div class="table-container"><h3 style="text-align:center;">Профиль X-Y</h3><table id="tableX"></table></div>
                <div class="table-container"><h3 style="text-align:center;">Профиль Z-Y</h3><table id="tableZ"></table></div>
            </div>
        </details>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Весь JavaScript-код из предыдущей версии остается здесь.
    // Изменения будут только в обработчиках экспорта.
    
    // --- Глобальные переменные и константы ---
    const DEFAULTS = {
        gridPoints: 100, minVal: -10, maxVal: 10,
        titleX: 'Ось X', titleY: 'Ось Y (Высота)', titleZ: 'Ось Z'
    };
    let settings = { ...DEFAULTS };
    let x_data, z_data, y_x_data, y_z_data;
    let isDragging = false;
    let editModeEnabled = false;

    // --- DOM Элементы ---
    const plotXDiv = document.getElementById('plotX');
    const plotZDiv = document.getElementById('plotZ');
    const plot3DDiv = document.getElementById('plot3D');
    // ... остальной код ...
    const controlsForm = document.getElementById('controls-form');
    const tableXContainer = document.getElementById('tableX');
    const tableZContainer = document.getElementById('tableZ');
    const modeToggleButton = document.getElementById('mode-toggle-btn');
    
    // ... весь остальной JS-код до функции main() остается без изменений ...
    // Копирую его сюда для полноты
    const linspace = (start, stop, num) => { const step = (stop - start) / (num - 1); return Array.from({ length: num }, (_, i) => start + i * step); };
    const outerProduct = (v1, v2) => v1.map(e1 => v2.map(e2 => e1 * e2));
    function saveStateToCache() { const state = { settings: settings, y_x_data: y_x_data, y_z_data: y_z_data, }; localStorage.setItem('surfacePlotState', JSON.stringify(state)); }
    function loadStateFromCache() {
        const savedStateJSON = localStorage.getItem('surfacePlotState');
        if (!savedStateJSON) return false;
        const savedState = JSON.parse(savedStateJSON);
        if (savedState.settings.gridPoints === settings.gridPoints && savedState.settings.minVal === settings.minVal && savedState.settings.maxVal === settings.maxVal && savedState.y_x_data && savedState.y_z_data && savedState.y_x_data.length === settings.gridPoints) {
            y_x_data = savedState.y_x_data; y_z_data = savedState.y_z_data; return true;
        } return false;
    }
    function generateDefaultProfileData() {
        const HUMP_HEIGHT = 2.0, HUMP_WIDTH = 3.0;
        const sigma = HUMP_WIDTH / (2 * Math.sqrt(2 * Math.log(2)));
        const center = (settings.minVal + settings.maxVal) / 2;
        const sigmaSq2 = 2 * sigma ** 2;
        y_x_data = x_data.map(coord => HUMP_HEIGHT * Math.exp(-((coord - center) ** 2) / sigmaSq2));
        y_z_data = z_data.map(coord => HUMP_HEIGHT * Math.exp(-((coord - center) ** 2) / sigmaSq2));
    }
    function generateAxisData() { x_data = linspace(settings.minVal, settings.maxVal, settings.gridPoints); z_data = linspace(settings.minVal, settings.maxVal, settings.gridPoints); }
    function updatePlots() {
        const HUMP_HEIGHT = 2.0;
        const { layoutX, layoutZ, layout3D } = getLayouts();
        Plotly.react(plotXDiv, [{ x: x_data, y: y_x_data, mode: 'lines+markers', marker: { size: 5, color: '#007bff' } }], layoutX);
        Plotly.react(plotZDiv, [{ x: z_data, y: y_z_data, mode: 'lines+markers', marker: { size: 5, color: 'red' } }], layoutZ);
        const surfaceData = outerProduct(y_z_data, y_x_data);
        const normalizedSurface = surfaceData.map(row => row.map(val => val / HUMP_HEIGHT));
        Plotly.react(plot3DDiv, [{ x: x_data, y: z_data, z: normalizedSurface, type: 'surface', colorscale: 'Viridis', cmin: -1, cmax: HUMP_HEIGHT }], layout3D);
        renderTables();
    }
    function getLayouts() {
        const HUMP_HEIGHT = 2.0;
        const commonYAxis = { title: settings.titleY, range: [-1, HUMP_HEIGHT + 2] };
        const dragMode2D = editModeEnabled ? false : 'zoom';
        return {
            layoutX: { xaxis: { title: settings.titleX }, yaxis: commonYAxis, margin: { l: 50, r: 30, b: 50, t: 10 }, dragmode: dragMode2D },
            layoutZ: { xaxis: { title: settings.titleZ }, yaxis: commonYAxis, margin: { l: 50, r: 30, b: 50, t: 10 }, dragmode: dragMode2D },
            layout3D: { scene: { xaxis: { title: settings.titleX }, yaxis: { title: settings.titleZ }, zaxis: { title: settings.titleY, range: [-1, HUMP_HEIGHT + 2] } }, margin: { l: 0, r: 0, b: 0, t: 10 } }
        };
    }
    controlsForm.addEventListener('input', (e) => {
        const inputId = e.target.id;
        const camelCaseId = inputId.replace(/-([a-z])/g, g => g[1].toUpperCase());
        let value = e.target.type === 'number' ? parseFloat(e.target.value) : e.target.value;
        if (isNaN(value) && e.target.type === 'number') return;
        const oldSettings = { ...settings };
        settings[camelCaseId] = value;
        if (settings.gridPoints !== oldSettings.gridPoints || settings.minVal !== oldSettings.minVal || settings.maxVal !== oldSettings.maxVal) { initializeApp(true); } else { updatePlots(); }
        saveStateToCache();
    });
    document.getElementById('reset-button').addEventListener('click', () => { if (confirm('Вы уверены?')) { localStorage.removeItem('surfacePlotState'); window.location.reload(); } });
    modeToggleButton.addEventListener('click', () => {
        editModeEnabled = !editModeEnabled;
        const { layoutX, layoutZ } = getLayouts();
        modeToggleButton.textContent = editModeEnabled ? 'Режим: Редактирование' : 'Режим: Навигация';
        modeToggleButton.classList.toggle('edit-mode', editModeEnabled);
        Plotly.relayout(plotXDiv, layoutX); Plotly.relayout(plotZDiv, layoutZ);
    });
    function setupPlotInteraction(plotDiv, dataArray) {
        plotDiv.on('plotly_hover', (eventData) => {
            if (!isDragging || !editModeEnabled || !eventData.points.length) return;
            const pointIndex = eventData.points[0].pointNumber;
            const newY = eventData.yvals[0];
            dataArray[pointIndex] = Math.max(-1, Math.min(newY, 2.0 + 2));
            Plotly.restyle(plotDiv, { y: [dataArray] }, [0]);
            update3DPlotOnly();
            const tableInput = (plotDiv === plotXDiv ? tableXContainer : tableZContainer).querySelector(`input[data-index="${pointIndex}"]`);
            if (tableInput) tableInput.value = dataArray[pointIndex].toFixed(3);
        });
    }
    window.addEventListener('mousedown', (e) => { if (e.button === 0 && editModeEnabled) isDragging = true; });
    window.addEventListener('mouseup', (e) => { if (e.button === 0 && isDragging) { isDragging = false; saveStateToCache(); } });
    function update3DPlotOnly() {
        const HUMP_HEIGHT = 2.0;
        const surfaceData = outerProduct(y_z_data, y_x_data);
        const normalizedSurface = surfaceData.map(row => row.map(val => val / HUMP_HEIGHT));
        Plotly.restyle(plot3DDiv, { z: [normalizedSurface] });
    }
    function initializeApp(forceRegenerate = false) {
        Object.keys(DEFAULTS).forEach(key => {
            const inputId = key.replace(/([A-Z])/g, '-$1').toLowerCase();
            const element = document.getElementById(inputId);
            settings[key] = element.type === 'number' ? parseFloat(element.value) : element.value;
        });
        generateAxisData();
        if (forceRegenerate || !loadStateFromCache()) { generateDefaultProfileData(); }
        updatePlots();
    }
    function renderTables() {
        const generateTableHTML = (axis, x_values, y_values) => `<thead><tr><th>${axis}</th><th>Y</th></tr></thead><tbody>${y_values.map((y, i) => `<tr><td>${x_values[i].toFixed(2)}</td><td><input type="number" step="0.1" value="${y.toFixed(3)}" data-index="${i}"></td></tr>`).join('')}</tbody>`;
        tableXContainer.innerHTML = generateTableHTML(settings.titleX, x_data, y_x_data);
        tableZContainer.innerHTML = generateTableHTML(settings.titleZ, z_data, y_z_data);
    }

    // *** НОВЫЙ КОД ДЛЯ ОБРАБОТКИ ЭКСПОРТА ***
    function setupExportButtons(plotWidgetId) {
        const widget = document.getElementById(plotWidgetId);
        const plotDivId = widget.querySelector('.plot-2d, .plot-3d').id;
        const plotDiv = document.getElementById(plotDivId);

        widget.querySelectorAll('.export-buttons button').forEach(button => {
            button.addEventListener('click', () => {
                const format = button.dataset.format;
                const filename = `${plotDivId}_export`;
                
                // Для PDF нужен другой подход и библиотеки уже подключены
                if (format === 'pdf') {
                    // Используем jsPDF напрямую для большего контроля
                    const { jsPDF } = window.jspdf;
                    Plotly.toImage(plotDiv, { format: 'png', width: 1200, height: 800 })
                        .then(function(dataUrl) {
                            const doc = new jsPDF({
                                orientation: 'landscape',
                                unit: 'pt',
                                format: [1200, 800]
                            });
                            doc.addImage(dataUrl, 'PNG', 0, 0, 1200, 800);
                            doc.save(`${filename}.pdf`);
                        });
                } else {
                    // Стандартный экспорт для PNG и SVG
                    Plotly.downloadImage(plotDiv, { format: format, width: 1200, height: 800, filename: filename });
                }
            });
        });
    }

    // --- Первичный запуск ---
    function main() {
        const savedStateJSON = localStorage.getItem('surfacePlotState');
        if (savedStateJSON) { const savedState = JSON.parse(savedStateJSON); settings = { ...DEFAULTS, ...savedState.settings }; }
        Object.keys(settings).forEach(key => {
            const inputId = key.replace(/([A-Z])/g, '-$1').toLowerCase();
            const element = document.getElementById(inputId);
            if (element) element.value = settings[key];
        });
        initializeApp();
        setupPlotInteraction(plotXDiv, y_x_data);
        setupPlotInteraction(plotZDiv, y_z_data);
        
        // Настраиваем кнопки экспорта для каждого виджета
        setupExportButtons('widget-plotX');
        setupExportButtons('widget-plotZ');
        setupExportButtons('widget-plot3D');

        function setupTableInteraction(tableContainer, dataArray, plotDiv) { /* ... без изменений ... */ }
        setupTableInteraction(tableXContainer, y_x_data, plotXDiv);
        setupTableInteraction(tableZContainer, y_z_data, plotZDiv);
        renderTables();
    }
    main();
});
</script>
</body>
</html>
