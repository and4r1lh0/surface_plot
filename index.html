import numpy as np
import matplotlib.pyplot as plt
from pyscript import display
import js
import io

# Класс для работы с localStorage браузера
class Storage:
    def get(self, key, default):
        value = js.window.localStorage.getItem(key)
        return value if value is not None else default
    
    def set(self, key, value):
        js.window.localStorage.setItem(key, value)
        
    def clear(self):
        js.window.localStorage.clear()

# Главный класс приложения
class App:
    def __init__(self):
        self.storage = Storage()
        self.load_settings()
        self.setup_event_listeners()
        self.rebuild_app()

    def load_settings(self):
        """Загружает настройки из localStorage и обновляет виджеты."""
        self.settings = {
            'grid_points': int(self.storage.get('grid_points', '50')),
            'min_val': float(self.storage.get('min_val', '-10')),
            'max_val': float(self.storage.get('max_val', '10')),
            'x_label': self.storage.get('x_label', 'Ось X'),
            'z_label': self.storage.get('z_label', 'Ось Z'),
            'y_label': self.storage.get('y_label', 'Y (Высота)')
        }
        # Устанавливаем значения в HTML-инпуты
        js.document.getElementById('grid-points').value = self.settings['grid_points']
        js.document.getElementById('min-val').value = self.settings['min_val']
        js.document.getElementById('max-val').value = self.settings['max_val']
        js.document.getElementById('x-axis-label').value = self.settings['x_label']
        js.document.getElementById('z-axis-label').value = self.settings['z_label']
        js.document.getElementById('y-axis-label').value = self.settings['y_label']

    def save_settings(self):
        """Читает значения из виджетов и сохраняет в localStorage."""
        self.settings['grid_points'] = int(js.document.getElementById('grid-points').value)
        self.settings['min_val'] = float(js.document.getElementById('min-val').value)
        self.settings['max_val'] = float(js.document.getElementById('max-val').value)
        self.settings['x_label'] = js.document.getElementById('x-axis-label').value
        self.settings['z_label'] = js.document.getElementById('z-axis-label').value
        self.settings['y_label'] = js.document.getElementById('y-axis-label').value
        
        for key, value in self.settings.items():
            self.storage.set(key, str(value))

    def setup_event_listeners(self):
        """Привязывает Python-функции к HTML-кнопкам."""
        js.document.getElementById('apply-settings').addEventListener('click', self.handle_apply_settings)
        js.document.getElementById('update-labels').addEventListener('click', self.handle_update_labels)
        js.document.getElementById('update-from-tables').addEventListener('click', self.handle_update_from_tables)
        js.document.getElementById('export-png').addEventListener('click', lambda e: self.export_figure('png'))
        js.document.getElementById('export-svg').addEventListener('click', lambda e: self.export_figure('svg'))
        js.document.getElementById('export-pdf').addEventListener('click', lambda e: self.export_figure('pdf'))
        js.document.getElementById('reset-settings').addEventListener('click', self.handle_reset)

    def rebuild_app(self):
        """Полностью перестраивает графики с текущими настройками."""
        self.cleanup_plots()
        self.dragger = ProfileDragger(self.settings)
        self.display_plots()
        self.render_tables()

    def cleanup_plots(self):
        """Очищает div'ы перед перерисовкой."""
        js.document.getElementById('plot-x-div').innerHTML = ""
        js.document.getElementById('plot-z-div').innerHTML = ""
        js.document.getElementById('plot-3d-div').innerHTML = ""
        plt.close('all') # Закрываем все фигуры matplotlib

    def display_plots(self):
        display(self.dragger.fig_x, target="plot-x-div")
        display(self.dragger.fig_z, target="plot-z-div")
        display(self.dragger.fig_3d, target="plot-3d-div")

    def render_tables(self):
        """Генерирует HTML для таблиц данных."""
        def create_table_html(coords, data, prefix):
            html = "<table><tr><th>Коорд.</th><th>Высота (Y)</th></tr>"
            for i, (coord, val) in enumerate(zip(coords, data)):
                html += f"<tr><td>{coord:.2f}</td><td><input type='number' step='0.1' id='{prefix}-{i}' value='{val:.2f}'></td></tr>"
            html += "</table>"
            return html

        x_html = create_table_html(self.dragger.x_data, self.dragger.y_x_data, 'table-x')
        z_html = create_table_html(self.dragger.z_data, self.dragger.y_z_data, 'table-z')
        js.document.getElementById('table-x-container').innerHTML = x_html
        js.document.getElementById('table-z-container').innerHTML = z_html

    # --- Обработчики событий ---
    def handle_apply_settings(self, event):
        self.save_settings()
        self.rebuild_app()

    def handle_update_labels(self, event):
        self.save_settings()
        self.dragger.update_labels(self.settings)

    def handle_update_from_tables(self, event):
        try:
            for i in range(len(self.dragger.y_x_data)):
                val = float(js.document.getElementById(f'table-x-{i}').value)
                self.dragger.y_x_data[i] = val
            for i in range(len(self.dragger.y_z_data)):
                val = float(js.document.getElementById(f'table-z-{i}').value)
                self.dragger.y_z_data[i] = val
            
            self.dragger.update_2d_plots_from_data()
            self.dragger.update_3d_plot()
        except Exception as e:
            js.alert(f"Ошибка при чтении данных из таблицы: {e}")

    def handle_reset(self, event):
        self.storage.clear()
        js.window.location.reload()

    def export_figure(self, format):
        """Сохраняет 3D-график и предлагает его скачать."""
        buf = io.BytesIO()
        self.dragger.fig_3d.savefig(buf, format=format, dpi=150, bbox_inches='tight')
        buf.seek(0)
        # JS-магия для скачивания файла
        file_blob = js.Blob.new([buf.getvalue()], {type: f'image/{format}'})
        link = js.document.createElement('a')
        link.href = js.window.URL.createObjectURL(file_blob)
        link.download = f'surface_plot_3d.{format}'
        link.click()

# Класс, управляющий логикой самих графиков
class ProfileDragger:
    def __init__(self, settings):
        self.settings = settings
        self.active_artist = None
        self.active_index = None
        
        # Данные
        self.x_data = np.linspace(settings['min_val'], settings['max_val'], settings['grid_points'])
        self.z_data = np.linspace(settings['min_val'], settings['max_val'], settings['grid_points'])
        
        def make_single_hump(coords):
            return 2.0 * np.exp(-((coords - (settings['min_val'] + settings['max_val']) / 2)**2) / (2 * ( (settings['max_val']-settings['min_val'])/6 )**2 ))
        
        self.y_x_data = make_single_hump(self.x_data)
        self.y_z_data = make_single_hump(self.z_data)
        self.X, self.Z = np.meshgrid(self.x_data, self.z_data)

        # Фигуры
        self.fig_x, self.ax_x = plt.subplots(figsize=(6, 4))
        self.fig_z, self.ax_z = plt.subplots(figsize=(6, 4))
        self.fig_3d = plt.figure(figsize=(6, 5))
        self.ax_3d = self.fig_3d.add_subplot(111, projection='3d')
        
        # Отрисовка
        self.line_x, = self.ax_x.plot(self.x_data, self.y_x_data, 'b-o', markersize=4)
        self.line_z, = self.ax_z.plot(self.z_data, self.y_z_data, 'r-o', markersize=4)
        
        # Подключение событий Matplotlib
        for fig in [self.fig_x, self.fig_z]:
            fig.canvas.mpl_connect('button_press_event', self.on_press)
            fig.canvas.mpl_connect('motion_notify_event', self.on_motion)
            fig.canvas.mpl_connect('button_release_event', self.on_release)
        
        self.update_labels(settings)
        self.update_3d_plot()

    def update_labels(self, settings):
        self.ax_x.set_title(f"Профиль по {settings['x_label']}")
        self.ax_x.set_xlabel(settings['x_label'])
        self.ax_x.set_ylabel(settings['y_label'])
        self.ax_x.grid(True)
        
        self.ax_z.set_title(f"Профиль по {settings['z_label']}")
        self.ax_z.set_xlabel(settings['z_label'])
        self.ax_z.set_ylabel(settings['y_label'])
        self.ax_z.grid(True)

        self.ax_3d.set_xlabel(settings['x_label'])
        self.ax_3d.set_ylabel(settings['z_label'])
        self.ax_3d.set_zlabel(settings['y_label'])
        
        for fig in [self.fig_x, self.fig_z, self.fig_3d]:
            fig.canvas.draw_idle()

    def update_3d_plot(self):
        # Сохраняем углы обзора камеры
        view = (self.ax_3d.elev, self.ax_3d.azim) if self.ax_3d.has_data() else (30, -60)
        self.ax_3d.clear()
        
        Y_3D = np.outer(self.y_x_data, self.y_z_data) / 2.0
        self.ax_3d.plot_surface(self.X, self.Z, Y_3D.T, cmap='viridis', rstride=2, cstride=2)
        
        self.update_labels(self.settings) # Восстанавливаем подписи
        self.ax_3d.view_init(elev=view[0], azim=view[1]) # Восстанавливаем камеру
        self.fig_3d.canvas.draw_idle()

    def update_2d_plots_from_data(self):
        self.line_x.set_ydata(self.y_x_data)
        self.line_z.set_ydata(self.y_z_data)
        self.fig_x.canvas.draw_idle()
        self.fig_z.canvas.draw_idle()

    def on_press(self, event):
        # Редактируем только по ПРАВОЙ кнопке мыши (button 3)
        if event.button != 3 or event.inaxes is None:
            return
            
        artist = self.line_x if event.inaxes == self.ax_x else self.line_z
        x_coords, y_coords = artist.get_data()
        distances = np.sqrt((x_coords - event.xdata)**2 + (y_coords - event.ydata)**2)
        
        if len(distances) > 0 and np.min(distances) < 0.5:
            self.active_artist = artist
            self.active_index = np.argmin(distances)

    def on_motion(self, event):
        if self.active_artist is None or event.inaxes is None:
            return
        
        y_data_arr = self.y_x_data if self.active_artist == self.line_x else self.y_z_data
        y_data_arr[self.active_index] = event.ydata
        self.active_artist.set_ydata(y_data_arr)
        self.active_artist.figure.canvas.draw_idle()

    def on_release(self, event):
        if self.active_artist and event.button == 3:
            self.active_artist = None
            self.active_index = None
            self.update_3d_plot()
            self.render_tables() # Обновляем таблицы после перетаскивания

# --- Запуск приложения ---
try:
    app = App()
    js.document.getElementById('loading-overlay').style.display = 'none'
except Exception as e:
    js.console.error(f"Ошибка при инициализации приложения: {e}")
    js.document.getElementById('loading-overlay').innerHTML = f"Произошла критическая ошибка: {e}"
