<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивная 3D Поверхность (JS + Plotly.js)</title>
    <!-- Подключаем библиотеку Plotly.js из CDN -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 1em;
            background-color: #f8f9fa;
        }
        h1, p {
            text-align: center;
        }
        .plot-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
        }
        .plot-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .plot-2d {
            width: 500px;
            height: 350px;
        }
        .plot-3d {
            width: 700px;
            height: 720px;
        }
    </style>
</head>

<body>

    <h1>Интерактивная 3D Поверхность</h1>
    <p>Перетаскивайте точки на 2D-графиках для изменения 3D-поверхности</p>

    <div class="plot-container">
        <div class="plot-wrapper">
            <!-- Контейнеры для 2D-графиков -->
            <div id="plotX" class="plot-2d"></div>
            <div id="plotZ" class="plot-2d"></div>
        </div>
        <!-- Контейнер для 3D-графика -->
        <div id="plot3D" class="plot-3d"></div>
    </div>

    <script>
    // --- Глобальные параметры (аналогично Python) ---
    const GRID_POINTS = 100;
    const HUMP_HEIGHT = 2.0;
    const HUMP_WIDTH = 3.0;

    // --- JavaScript-аналоги функций NumPy ---

    /**
     * Создает массив чисел в заданном диапазоне (аналог np.linspace).
     */
    function linspace(start, stop, num) {
        const step = (stop - start) / (num - 1);
        return Array.from({ length: num }, (_, i) => start + i * step);
    }

    /**
     * Создает гауссовский горб (аналог make_single_hump).
     */
    function makeSingleHump(coords) {
        const sigma = HUMP_WIDTH / (2 * Math.sqrt(2 * Math.log(2)));
        const center = 0.0;
        const sigmaSq2 = 2 * sigma ** 2;
        return coords.map(coord => HUMP_HEIGHT * Math.exp(-((coord - center) ** 2) / sigmaSq2));
    }

    /**
     * Вычисляет внешнее произведение двух векторов для создания поверхности (аналог np.outer).
     */
    function outerProduct(v1, v2) {
        return v1.map(e1 => v2.map(e2 => e1 * e2));
    }

    // --- Исходные данные ---
    const x_data = linspace(-10, 10, GRID_POINTS);
    const z_data = linspace(-10, 10, GRID_POINTS);
    let y_x_data = makeSingleHump(x_data);
    let y_z_data = makeSingleHump(z_data);

    // --- Получаем ссылки на DOM-элементы ---
    const plotXDiv = document.getElementById('plotX');
    const plotZDiv = document.getElementById('plotZ');
    const plot3DDiv = document.getElementById('plot3D');

    // --- Определяем макеты (layout) для графиков ---
    const layoutX = {
        title: 'Профиль по оси X (Y от X)',
        xaxis: { title: 'X' },
        yaxis: { title: 'Y', range: [-1, HUMP_HEIGHT + 2] },
        margin: { l: 50, r: 30, b: 50, t: 50 }
    };

    const layoutZ = {
        title: 'Профиль по оси Z (Y от Z)',
        xaxis: { title: 'Z' },
        yaxis: { title: 'Y', range: [-1, HUMP_HEIGHT + 2] },
        margin: { l: 50, r: 30, b: 50, t: 50 }
    };

    const layout3D = {
        title: 'Итоговая 3D-поверхность',
        scene: {
            xaxis: { title: 'Ось X' },
            yaxis: { title: 'Ось Z' },
            zaxis: { title: 'Ось Y (Высота)', range: [-1, HUMP_HEIGHT + 2] }
        },
        margin: { l: 0, r: 0, b: 0, t: 40 }
    };
    
    // --- Функция обновления 3D-поверхности ---
    function update3DPlot() {
        const surfaceData = outerProduct(y_z_data, y_x_data);
        const normalizedSurface = surfaceData.map(row => row.map(val => val / HUMP_HEIGHT));

        // Используем Plotly.react для эффективного обновления данных без полной перерисовки
        Plotly.react(plot3DDiv, [{
            x: x_data,
            y: z_data,
            z: normalizedSurface,
            type: 'surface',
            colorscale: 'Viridis',
            cmin: -1,
            cmax: HUMP_HEIGHT
        }], layout3D);
    }

    // --- Первичная отрисовка всех графиков ---
    Plotly.newPlot(plotXDiv, [{ x: x_data, y: y_x_data, mode: 'lines+markers', marker: {size: 5} }], layoutX);
    Plotly.newPlot(plotZDiv, [{ x: z_data, y: y_z_data, mode: 'lines+markers', marker: {size: 5, color: 'red'} }], layoutZ);
    update3DPlot(); // Первичная отрисовка 3D-графика

    // --- Логика интерактивного перетаскивания ---
    let isDragging = false;

    // Функция-обработчик для обновления 2D-точек
    function handleInteraction(eventData, plotDiv, dataArray, plotType) {
        // eventData содержит информацию о событии, включая координаты точки
        if (!eventData || !eventData.points || eventData.points.length === 0) return;

        // Находим индекс ближайшей точки и новую y-координату курсора
        const pointIndex = eventData.points[0].pointNumber;
        const newY = eventData.yvals[0];

        // Ограничиваем перемещение по оси Y
        dataArray[pointIndex] = Math.max(-1, Math.min(newY, HUMP_HEIGHT + 2));

        // Обновляем только y-координаты на 2D-графике. Это очень быстро.
        Plotly.restyle(plotDiv, { y: [dataArray] }, [0]);
    }

    // Глобальные слушатели мыши для отслеживания состояния перетаскивания
    window.addEventListener('mousedown', () => { isDragging = true; });
    window.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
            // Обновляем 3D-график только после того, как отпустили кнопку мыши
            update3DPlot();
        }
    });

    // Вешаем обработчики событий на 2D-графики
    plotXDiv.on('plotly_click', (d) => handleInteraction(d, plotXDiv, y_x_data, 'X'));
    plotXDiv.on('plotly_hover', (d) => {
        if (isDragging) {
            handleInteraction(d, plotXDiv, y_x_data, 'X');
        }
    });

    plotZDiv.on('plotly_click', (d) => handleInteraction(d, plotZDiv, y_z_data, 'Z'));
    plotZDiv.on('plotly_hover', (d) => {
        if (isDragging) {
            handleInteraction(d, plotZDiv, y_z_data, 'Z');
        }
    });

    </script>
</body>
</html>
